{"version":3,"file":"3534.9066302c.iframe.bundle.js","mappings":";;;;;;;;;;;AA+BA;;;;;;;;AASA;;;;;;;;;;;;AAaA;;;;AAwBA;;;AAGA;AACA;AACA;;;AAGA;AACA;;;AAGA;;;;;;;;;AASA;;AAEA;AACA;AACA;;;AAGA;;;;;AAKA;;AAEA;;;;AAIA;;;;ACzGA;;;;;;;;;;ACoSA","sources":["webpack://gitlanding/./node_modules/@mui/material/ButtonBase/TouchRipple.js","webpack://gitlanding/./node_modules/@storybook/addon-docs/blocks.js","webpack://gitlanding/./node_modules/onyxia-ui/lib/SplashScreen.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"center\", \"classes\", \"className\"];\nlet _ = t => t,\n  _t,\n  _t2,\n  _t3,\n  _t4;\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { TransitionGroup } from 'react-transition-group';\nimport clsx from 'clsx';\nimport { keyframes } from '@mui/system';\nimport styled from '../styles/styled';\nimport useThemeProps from '../styles/useThemeProps';\nimport Ripple from './Ripple';\nimport touchRippleClasses from './touchRippleClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DURATION = 550;\nexport const DELAY_RIPPLE = 80;\nconst enterKeyframe = keyframes(_t || (_t = _`\n  0% {\n    transform: scale(0);\n    opacity: 0.1;\n  }\n\n  100% {\n    transform: scale(1);\n    opacity: 0.3;\n  }\n`));\nconst exitKeyframe = keyframes(_t2 || (_t2 = _`\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n`));\nconst pulsateKeyframe = keyframes(_t3 || (_t3 = _`\n  0% {\n    transform: scale(1);\n  }\n\n  50% {\n    transform: scale(0.92);\n  }\n\n  100% {\n    transform: scale(1);\n  }\n`));\nexport const TouchRippleRoot = styled('span', {\n  name: 'MuiTouchRipple',\n  slot: 'Root'\n})({\n  overflow: 'hidden',\n  pointerEvents: 'none',\n  position: 'absolute',\n  zIndex: 0,\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n  borderRadius: 'inherit'\n});\n\n// This `styled()` function invokes keyframes. `styled-components` only supports keyframes\n// in string templates. Do not convert these styles in JS object as it will break.\nexport const TouchRippleRipple = styled(Ripple, {\n  name: 'MuiTouchRipple',\n  slot: 'Ripple'\n})(_t4 || (_t4 = _`\n  opacity: 0;\n  position: absolute;\n\n  &.${0} {\n    opacity: 0.3;\n    transform: scale(1);\n    animation-name: ${0};\n    animation-duration: ${0}ms;\n    animation-timing-function: ${0};\n  }\n\n  &.${0} {\n    animation-duration: ${0}ms;\n  }\n\n  & .${0} {\n    opacity: 1;\n    display: block;\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    background-color: currentColor;\n  }\n\n  & .${0} {\n    opacity: 0;\n    animation-name: ${0};\n    animation-duration: ${0}ms;\n    animation-timing-function: ${0};\n  }\n\n  & .${0} {\n    position: absolute;\n    /* @noflip */\n    left: 0px;\n    top: 0;\n    animation-name: ${0};\n    animation-duration: 2500ms;\n    animation-timing-function: ${0};\n    animation-iteration-count: infinite;\n    animation-delay: 200ms;\n  }\n`), touchRippleClasses.rippleVisible, enterKeyframe, DURATION, ({\n  theme\n}) => theme.transitions.easing.easeInOut, touchRippleClasses.ripplePulsate, ({\n  theme\n}) => theme.transitions.duration.shorter, touchRippleClasses.child, touchRippleClasses.childLeaving, exitKeyframe, DURATION, ({\n  theme\n}) => theme.transitions.easing.easeInOut, touchRippleClasses.childPulsate, pulsateKeyframe, ({\n  theme\n}) => theme.transitions.easing.easeInOut);\n\n/**\n * @ignore - internal component.\n *\n * TODO v5: Make private\n */\nconst TouchRipple = /*#__PURE__*/React.forwardRef(function TouchRipple(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiTouchRipple'\n  });\n  const {\n      center: centerProp = false,\n      classes = {},\n      className\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const [ripples, setRipples] = React.useState([]);\n  const nextKey = React.useRef(0);\n  const rippleCallback = React.useRef(null);\n  React.useEffect(() => {\n    if (rippleCallback.current) {\n      rippleCallback.current();\n      rippleCallback.current = null;\n    }\n  }, [ripples]);\n\n  // Used to filter out mouse emulated events on mobile.\n  const ignoringMouseDown = React.useRef(false);\n  // We use a timer in order to only show the ripples for touch \"click\" like events.\n  // We don't want to display the ripple for touch scroll events.\n  const startTimer = React.useRef(null);\n\n  // This is the hook called once the previous timeout is ready.\n  const startTimerCommit = React.useRef(null);\n  const container = React.useRef(null);\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(startTimer.current);\n    };\n  }, []);\n  const startCommit = React.useCallback(params => {\n    const {\n      pulsate,\n      rippleX,\n      rippleY,\n      rippleSize,\n      cb\n    } = params;\n    setRipples(oldRipples => [...oldRipples, /*#__PURE__*/_jsx(TouchRippleRipple, {\n      classes: {\n        ripple: clsx(classes.ripple, touchRippleClasses.ripple),\n        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),\n        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),\n        child: clsx(classes.child, touchRippleClasses.child),\n        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),\n        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)\n      },\n      timeout: DURATION,\n      pulsate: pulsate,\n      rippleX: rippleX,\n      rippleY: rippleY,\n      rippleSize: rippleSize\n    }, nextKey.current)]);\n    nextKey.current += 1;\n    rippleCallback.current = cb;\n  }, [classes]);\n  const start = React.useCallback((event = {}, options = {}, cb = () => {}) => {\n    const {\n      pulsate = false,\n      center = centerProp || options.pulsate,\n      fakeElement = false // For test purposes\n    } = options;\n    if ((event == null ? void 0 : event.type) === 'mousedown' && ignoringMouseDown.current) {\n      ignoringMouseDown.current = false;\n      return;\n    }\n    if ((event == null ? void 0 : event.type) === 'touchstart') {\n      ignoringMouseDown.current = true;\n    }\n    const element = fakeElement ? null : container.current;\n    const rect = element ? element.getBoundingClientRect() : {\n      width: 0,\n      height: 0,\n      left: 0,\n      top: 0\n    };\n\n    // Get the size of the ripple\n    let rippleX;\n    let rippleY;\n    let rippleSize;\n    if (center || event === undefined || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {\n      rippleX = Math.round(rect.width / 2);\n      rippleY = Math.round(rect.height / 2);\n    } else {\n      const {\n        clientX,\n        clientY\n      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;\n      rippleX = Math.round(clientX - rect.left);\n      rippleY = Math.round(clientY - rect.top);\n    }\n    if (center) {\n      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);\n\n      // For some reason the animation is broken on Mobile Chrome if the size is even.\n      if (rippleSize % 2 === 0) {\n        rippleSize += 1;\n      }\n    } else {\n      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;\n      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;\n      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);\n    }\n\n    // Touche devices\n    if (event != null && event.touches) {\n      // check that this isn't another touchstart due to multitouch\n      // otherwise we will only clear a single timer when unmounting while two\n      // are running\n      if (startTimerCommit.current === null) {\n        // Prepare the ripple effect.\n        startTimerCommit.current = () => {\n          startCommit({\n            pulsate,\n            rippleX,\n            rippleY,\n            rippleSize,\n            cb\n          });\n        };\n        // Delay the execution of the ripple effect.\n        startTimer.current = setTimeout(() => {\n          if (startTimerCommit.current) {\n            startTimerCommit.current();\n            startTimerCommit.current = null;\n          }\n        }, DELAY_RIPPLE); // We have to make a tradeoff with this value.\n      }\n    } else {\n      startCommit({\n        pulsate,\n        rippleX,\n        rippleY,\n        rippleSize,\n        cb\n      });\n    }\n  }, [centerProp, startCommit]);\n  const pulsate = React.useCallback(() => {\n    start({}, {\n      pulsate: true\n    });\n  }, [start]);\n  const stop = React.useCallback((event, cb) => {\n    clearTimeout(startTimer.current);\n\n    // The touch interaction occurs too quickly.\n    // We still want to show ripple effect.\n    if ((event == null ? void 0 : event.type) === 'touchend' && startTimerCommit.current) {\n      startTimerCommit.current();\n      startTimerCommit.current = null;\n      startTimer.current = setTimeout(() => {\n        stop(event, cb);\n      });\n      return;\n    }\n    startTimerCommit.current = null;\n    setRipples(oldRipples => {\n      if (oldRipples.length > 0) {\n        return oldRipples.slice(1);\n      }\n      return oldRipples;\n    });\n    rippleCallback.current = cb;\n  }, []);\n  React.useImperativeHandle(ref, () => ({\n    pulsate,\n    start,\n    stop\n  }), [pulsate, start, stop]);\n  return /*#__PURE__*/_jsx(TouchRippleRoot, _extends({\n    className: clsx(touchRippleClasses.root, classes.root, className),\n    ref: container\n  }, other, {\n    children: /*#__PURE__*/_jsx(TransitionGroup, {\n      component: null,\n      exit: true,\n      children: ripples\n    })\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? TouchRipple.propTypes = {\n  /**\n   * If `true`, the ripple starts at the center of the component\n   * rather than at the point of interaction.\n   */\n  center: PropTypes.bool,\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string\n} : void 0;\nexport default TouchRipple;","import deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\n\nconst warnBlocksImport = deprecate(\n  () => {},\n  dedent`\n    Importing from '@storybook/addon-docs/blocks' is deprecated, import directly from '@storybook/addon-docs' instead:\n    \n    https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-scoped-blocks-imports\n`\n);\nwarnBlocksImport();\n\nexport * from './dist/esm/blocks';\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createOnyxiaSplashScreenLogo = exports.createSplashScreen = exports.useSplashScreen = void 0;\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst react_1 = require(\"react\");\nconst color_1 = __importDefault(require(\"color\"));\nconst hooks_1 = require(\"evt/hooks\");\nconst useGlobalState_1 = require(\"powerhooks/useGlobalState\");\nconst useConstCallback_1 = require(\"powerhooks/useConstCallback\");\nconst tss_react_1 = require(\"tss-react\");\nconst evt_1 = require(\"evt\");\nconst id_1 = require(\"tsafe/id\");\nconst useGuaranteedMemo_1 = require(\"powerhooks/useGuaranteedMemo\");\nconst runExclusive = __importStar(require(\"run-exclusive\"));\nconst OnyxiaLogo_1 = require(\"../assets/svg/OnyxiaLogo\");\nconst useConst_1 = require(\"powerhooks/useConst\");\nconst ViewPortAdapter_1 = require(\"powerhooks/ViewPortAdapter\");\nconst statefulObservableToStatefulEvt_1 = require(\"powerhooks/tools/StatefulObservable/statefulObservableToStatefulEvt\");\nlet fadeOutDuration = 700;\nlet minimumDisplayDuration = 1000;\nconst { useSplashScreen, useSplashScreenStatus } = (() => {\n    const evtDisplayState = evt_1.Evt.create({\n        \"count\": 1,\n        \"isTransparencyEnabled\": false,\n        \"prevTime\": 0,\n        \"onHiddens\": (0, id_1.id)([]),\n    });\n    const { globalHideSplashScreen } = (() => {\n        const { getDoUseDelay } = (() => {\n            const { $lastDelayedTime } = (0, useGlobalState_1.createUseGlobalState)({\n                \"name\": \"lastDelayedTime\",\n                \"initialState\": 0,\n                \"doPersistAcrossReloads\": true,\n            });\n            const evtLastDelayedTime = (0, statefulObservableToStatefulEvt_1.statefulObservableToStatefulEvt)({\n                \"statefulObservable\": $lastDelayedTime,\n            });\n            function getDoUseDelay() {\n                const doUseDelay = Date.now() - evtLastDelayedTime.state > 30000;\n                if (doUseDelay) {\n                    evtLastDelayedTime.state = Date.now();\n                }\n                return doUseDelay;\n            }\n            return { getDoUseDelay };\n        })();\n        const next = runExclusive.build(() => __awaiter(void 0, void 0, void 0, function* () {\n            if (getDoUseDelay()) {\n                yield new Promise(resolve => setTimeout(resolve, minimumDisplayDuration));\n            }\n            evtDisplayState.state = Object.assign(Object.assign({}, evtDisplayState.state), { \"prevTime\": Date.now() });\n        }));\n        function globalHideSplashScreen() {\n            return __awaiter(this, void 0, void 0, function* () {\n                evtDisplayState.state.count = Math.max(evtDisplayState.state.count - 1, 0);\n                if (runExclusive.isRunning(next)) {\n                    return;\n                }\n                next();\n            });\n        }\n        return { globalHideSplashScreen };\n    })();\n    function globalShowSplashScreen(params) {\n        evtDisplayState.state = {\n            \"count\": evtDisplayState.state.count + 1,\n            \"isTransparencyEnabled\": params.enableTransparency,\n            \"prevTime\": Date.now(),\n            \"onHiddens\": [],\n        };\n    }\n    function useSplashScreenStatusInternal() {\n        (0, hooks_1.useRerenderOnStateChange)(evtDisplayState);\n        const { isSplashScreenShown, isTransparencyEnabled } = (0, useGuaranteedMemo_1.useGuaranteedMemo)(() => ({\n            \"isSplashScreenShown\": evtDisplayState.state.count > 0,\n            \"isTransparencyEnabled\": evtDisplayState.state.isTransparencyEnabled,\n        }), [evtDisplayState.state]);\n        return {\n            isSplashScreenShown,\n            isTransparencyEnabled,\n        };\n    }\n    function useSplashScreen(params) {\n        if ((params === null || params === void 0 ? void 0 : params.fadeOutDuration) !== undefined) {\n            fadeOutDuration = params.fadeOutDuration;\n        }\n        if ((params === null || params === void 0 ? void 0 : params.minimumDisplayDuration) !== undefined) {\n            minimumDisplayDuration = params.minimumDisplayDuration;\n        }\n        const isUsingSplashScreen = (0, react_1.useContext)(context);\n        (0, react_1.useEffect)(() => {\n            const { onHidden } = params !== null && params !== void 0 ? params : {};\n            if (onHidden === undefined) {\n                return;\n            }\n            if (!isUsingSplashScreen) {\n                onHidden();\n                return;\n            }\n            evtDisplayState.state.onHiddens.push(onHidden);\n        }, []);\n        const { showSplashScreen, hideSplashScreen } = (function useClosure() {\n            const countRef = (0, react_1.useRef)(0);\n            const showSplashScreen = (0, useConstCallback_1.useConstCallback)(({ enableTransparency }) => {\n                countRef.current++;\n                globalShowSplashScreen({ enableTransparency });\n            });\n            const hideSplashScreen = (0, useConstCallback_1.useConstCallback)(() => __awaiter(this, void 0, void 0, function* () {\n                if (countRef.current === 0) {\n                    return;\n                }\n                countRef.current--;\n                yield globalHideSplashScreen();\n            }));\n            return { showSplashScreen, hideSplashScreen };\n        })();\n        const { isSplashScreenShown, isTransparencyEnabled } = useSplashScreenStatusInternal();\n        return {\n            isSplashScreenShown,\n            isTransparencyEnabled,\n            \"hideRootSplashScreen\": globalHideSplashScreen,\n            showSplashScreen,\n            hideSplashScreen,\n        };\n    }\n    function useSplashScreenStatus() {\n        const { isSplashScreenShown, isTransparencyEnabled } = useSplashScreenStatusInternal();\n        (0, react_1.useEffect)(() => {\n            var _a;\n            if (isSplashScreenShown) {\n                return;\n            }\n            const delayLeft = (_a = [\n                fadeOutDuration -\n                    (Date.now() - evtDisplayState.state.prevTime),\n            ].filter(v => v > 0)[0]) !== null && _a !== void 0 ? _a : 0;\n            let timer;\n            (() => __awaiter(this, void 0, void 0, function* () {\n                yield new Promise(resolve => (timer = setTimeout(resolve, delayLeft)));\n                evtDisplayState.state.onHiddens.forEach(onHidden => onHidden());\n                evtDisplayState.state.onHiddens = [];\n            }))();\n            return () => clearTimeout(timer);\n        }, [isSplashScreenShown]);\n        return { isSplashScreenShown, isTransparencyEnabled };\n    }\n    return { useSplashScreen, useSplashScreenStatus };\n})();\nexports.useSplashScreen = useSplashScreen;\nconst context = (0, react_1.createContext)(false);\nfunction createSplashScreen(params) {\n    const { useTheme } = params;\n    function SplashScreen(props) {\n        const { children, Logo } = props;\n        if ((props === null || props === void 0 ? void 0 : props.fadeOutDuration) !== undefined) {\n            fadeOutDuration = props.fadeOutDuration;\n        }\n        if ((props === null || props === void 0 ? void 0 : props.minimumDisplayDuration) !== undefined) {\n            minimumDisplayDuration = props.minimumDisplayDuration;\n        }\n        const { isSplashScreenShown, isTransparencyEnabled } = useSplashScreenStatus();\n        {\n            const defaultOverflow = (0, useConst_1.useConst)(() => document.body.style.overflow);\n            (0, react_1.useEffect)(() => {\n                document.body.style.overflow = isSplashScreenShown\n                    ? \"hidden\"\n                    : defaultOverflow;\n            }, [isSplashScreenShown]);\n        }\n        const [isFadingOut, setIsFadingOut] = (0, react_1.useState)(false);\n        const [isVisible, setIsVisible] = (0, react_1.useState)(true);\n        const { isViewPortAdapterEnabled } = (function useClosure() {\n            const { viewPortState } = (0, ViewPortAdapter_1.useViewPortState)();\n            const isViewPortAdapterEnabled = viewPortState !== undefined;\n            return { isViewPortAdapterEnabled };\n        })();\n        const { classes } = useStyles({\n            \"theme\": useTheme(),\n            isVisible,\n            isFadingOut,\n            isTransparencyEnabled,\n            isViewPortAdapterEnabled,\n        });\n        (0, react_1.useEffect)(() => {\n            let timer = setTimeout(() => {\n                /* No action */\n            }, 0);\n            (() => __awaiter(this, void 0, void 0, function* () {\n                if (isSplashScreenShown) {\n                    setIsFadingOut(false);\n                    setIsVisible(true);\n                }\n                else {\n                    setIsFadingOut(true);\n                    yield new Promise(resolve => (timer = setTimeout(resolve, fadeOutDuration)));\n                    setIsFadingOut(false);\n                    setIsVisible(false);\n                }\n            }))();\n            return () => clearTimeout(timer);\n        }, [isSplashScreenShown]);\n        return ((0, jsx_runtime_1.jsxs)(context.Provider, Object.assign({ value: true }, { children: [(0, jsx_runtime_1.jsx)(\"div\", Object.assign({ className: classes.root }, { children: (0, jsx_runtime_1.jsx)(Logo, {}) })), children] })));\n    }\n    const useStyles = tss_react_1.tss\n        .withParams()\n        .withName({ SplashScreen })\n        .create(({ theme, isVisible, isFadingOut, isTransparencyEnabled, isViewPortAdapterEnabled, }) => ({\n        \"root\": {\n            \"width\": \"100%\",\n            \"height\": isViewPortAdapterEnabled ? \"100%\" : \"100vh\",\n            \"position\": \"fixed\",\n            \"top\": 0,\n            \"left\": 0,\n            \"zIndex\": 10,\n            \"backgroundColor\": (() => {\n                const color = new color_1.default(theme.colors.useCases.surfaces.background).rgb();\n                return color\n                    .alpha(isTransparencyEnabled\n                    ? 0.6\n                    : color.valpha)\n                    .string();\n            })(),\n            \"backdropFilter\": isTransparencyEnabled\n                ? \"blur(10px)\"\n                : undefined,\n            \"display\": \"flex\",\n            \"alignItems\": \"center\",\n            \"justifyContent\": \"center\",\n            \"visibility\": isVisible ? \"visible\" : \"hidden\",\n            \"opacity\": isFadingOut ? 0 : 1,\n            \"transition\": `opacity ease-in-out ${fadeOutDuration}ms`,\n        },\n    }));\n    return { SplashScreen };\n}\nexports.createSplashScreen = createSplashScreen;\n/**\n * You have to create your own version of this component\n * you are expected to size it in percentage.\n */\nfunction createOnyxiaSplashScreenLogo(params) {\n    const { useTheme } = params;\n    const OnyxiaSplashScreenLogo = (0, react_1.memo)(() => {\n        const { classes } = useStyles({\n            \"theme\": useTheme(),\n        });\n        return (0, jsx_runtime_1.jsx)(OnyxiaLogo_1.OnyxiaLogoSvg, { className: classes.root });\n    });\n    const useStyles = tss_react_1.tss\n        .withParams()\n        .withName({ OnyxiaSplashScreenLogo })\n        .create(({ theme }) => ({\n        \"root\": {\n            \"height\": \"20%\",\n            \"fill\": theme.colors.useCases.typography.textFocus,\n            \"& g\": {\n                \"opacity\": 0,\n                \"animation\": `${(0, tss_react_1.keyframes) `\n                            60%, 100% {\n                                opacity: 0;\n                            }\n                            0% {\n                                opacity: 0;\n                            }\n                            40% {\n                                opacity: 1;\n                            }\n                            `} 3.5s infinite ease-in-out`,\n                \"&:nth-of-type(1)\": {\n                    \"animationDelay\": \".4s\",\n                },\n                \"&:nth-of-type(2)\": {\n                    \"animationDelay\": \".8s\",\n                },\n                \"&:nth-of-type(3)\": {\n                    \"animationDelay\": \"1.2s\",\n                },\n            },\n        },\n    }));\n    return { OnyxiaSplashScreenLogo };\n}\nexports.createOnyxiaSplashScreenLogo = createOnyxiaSplashScreenLogo;\n//# sourceMappingURL=SplashScreen.js.map"],"names":[],"sourceRoot":""}